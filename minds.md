- Проблемы с точностью в FFT
  - Либо делаем КТО по n > 1 разным модулям.
  - Либо говорим, что f = K * f1 + f2, g = K * g1 + g2, где K ~ sqrt(mod), и коэффициенты у f2 и g2 < K. Тогда f * g = K * K * f1 * g1 + K * (f1 * g2 + g1 * f2) + f2 * g2, смысл в том что во всех многочленах коэффициенты порядка корня.

- Перечисление всех пифагоровых троек
  - https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D1%85_%D0%BF%D0%B8%D1%84%D0%B0%D0%B3%D0%BE%D1%80%D0%BE%D0%B2%D1%8B%D1%85_%D1%82%D1%80%D0%BE%D0%B5%D0%BA

- Largest sum of *k* increasing subsequences
  - Для k = 1 решение как в НОП с бинпоиском
  - Для больших k, тот элемент, который выкидывается после добавлении нового, уходит на слой ниже и вставляется в следующий слой
  - Можно построить биекцию между перестановками и таблицей Юнга из этого алгоритма, если в пару к этой диаграмме добавить еще одну, в которой число означает на каком шаге была добавлена ячейка

- Формула Крюков для подсчета числа таблиц Юнга (диаграмма Юнга задает форму, а в таблице раставлены числа, что для каждого элемента все справа и ниже от него больше него, и все числа образуют перестановку)
  - https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0_%D0%AE%D0%BD%D0%B3%D0%B0

- Про свертки
  - В свертке вида c[(i \* j) % p] += a[i] \* b[j] делаем дискретное логарифмирование и переходим к сложению, далее FFT.

- Формула Кэли для кол-ва деревьев:
  - n^(n-2)
  - TODO: добавить формулу для количества унициклических графов

- Количество деревьев с путем длины k между двумя конкретными вершинами:
  - (k+1) * n^(n-k-2) * (n-2)! / (n-k-2)! 

- Количество лесов из n вершин и k деревьев:
  - sum by i from 0 to k:
  - (-1/2)^i * (k+i) * i! * C(k, i) * C(n-k, i) * n^(n-k-i-1)

- Решаем задачи на посчитать по всем объектам f(object)^k `<=>` количество способов выбрать объект + последовательность длины k, членами которой являются члены f, а теперь решаем для последовательности
  - (к примеру, посчитаь size^k для всех связных подграфов дерева, k <= 10 вместо size^k выбираем подграф + последовательность из k его вершин теперь простая DP по поддеревьям)

- Задача по модулю p - возможно стоит дискретно логарифмировать (т.е если x = pr_root ^ y, то заменим x на y), тогда произведение переходит в сумму (a*b = pr_root ^ x * pr_root ^ y = (pr_root)^(x+y))

- DCP offline: если решать через ДО, то обрабатывать запрос можно не в листе дерева, а в каждой вершине ДО обновлять ответ на все запросы в поддереве.
